[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "LazyLM",
    "section": "",
    "text": "In the rapidly evolving landscape of artificial intelligence, large language models (LLMs) have emerged as powerful tools for a wide range of applications, from content creation to complex problem-solving. We’ve seen widespread adoption of language models as “assistants” in various domains, such as healthcare, education, and content creation. However, in educational contexts, these models often fall short of providing an optimal learning experience. They tend to generate complete solutions upfront, robbing students of the opportunity to engage in the step-by-step reasoning process that is crucial for deep understanding.\nThis raises an important question:\n\nCan we get these systems to evaluate in a ‘Socratic’ way?\n\nIn other words, can we develop systems that encourage students to think step-by-step, rather than generating complete solutions upfront?\nWhile there has been significant work on making LLMs reason step-by-step (e.g., chain-of-thought prompting), to our knowledge, there isn’t an existing framework to build systems that allow users to think through problems step-by-step while having the LLM assist in a pedagogical way. This is where the concept of “lazy evaluation” in language models comes into play, offering a more Socratic approach to AI-assisted tasks.\nThis work demonstrates an approach to building a framework for forcing models to evaluate in a lazy way, drawing inspiration from functional programming concepts.",
    "crumbs": [
      "LazyLM"
    ]
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "LazyLM",
    "section": "",
    "text": "In the rapidly evolving landscape of artificial intelligence, large language models (LLMs) have emerged as powerful tools for a wide range of applications, from content creation to complex problem-solving. We’ve seen widespread adoption of language models as “assistants” in various domains, such as healthcare, education, and content creation. However, in educational contexts, these models often fall short of providing an optimal learning experience. They tend to generate complete solutions upfront, robbing students of the opportunity to engage in the step-by-step reasoning process that is crucial for deep understanding.\nThis raises an important question:\n\nCan we get these systems to evaluate in a ‘Socratic’ way?\n\nIn other words, can we develop systems that encourage students to think step-by-step, rather than generating complete solutions upfront?\nWhile there has been significant work on making LLMs reason step-by-step (e.g., chain-of-thought prompting), to our knowledge, there isn’t an existing framework to build systems that allow users to think through problems step-by-step while having the LLM assist in a pedagogical way. This is where the concept of “lazy evaluation” in language models comes into play, offering a more Socratic approach to AI-assisted tasks.\nThis work demonstrates an approach to building a framework for forcing models to evaluate in a lazy way, drawing inspiration from functional programming concepts.",
    "crumbs": [
      "LazyLM"
    ]
  },
  {
    "objectID": "index.html#motivation",
    "href": "index.html#motivation",
    "title": "LazyLM",
    "section": "Motivation",
    "text": "Motivation\nThe motivation behind implementing lazy evaluation in language models stems from several key observations:\n\nPedagogical Effectiveness: Traditional tutoring methods often involve guiding students through problems step-by-step, allowing them to think critically and make connections on their own. AI tutors should aim to replicate this approach rather than simply providing answers.\nResource Efficiency: Generating complete solutions upfront is computationally expensive, especially for complex problems. A lazy evaluation approach can significantly reduce resource usage by generating only the necessary information on demand.\nAdaptability: Students have varying levels of understanding and may require different amounts of guidance. A lazy evaluation system can adapt to each student’s needs, providing more or less detail as required.\nEngagement: By revealing information gradually, we can maintain student engagement and encourage active participation in the problem-solving process.\nReal-world Problem Solving: In many real-world scenarios, solutions are not immediately apparent and must be approached incrementally. Training students to think in this way prepares them for challenges beyond the classroom.\n\nInstalling LazyLM\npip install lazy_lm\nUsing LazyLM\n\nfrom dotenv import load_dotenv\nimport os\nfrom anthropic import AnthropicVertex\nfrom lazy_lm.core import lazy\n\nload_dotenv()\nproject_id = os.getenv(\"PROJECT_ID\")\nlocation = os.getenv(\"PROJECT_LOCATION\")\n\n\n# Initalize the Anthropic client\nclient = AnthropicVertex(project_id=project_id, region=location)\nlazy_lm = client.lazy(\"What is the derivative of `2x^3 + x^2 + 2x + 1`? Give me the solution step-by-step\")\n\n\n# Get the current step\nprint(lazy_lm.get_current_step())\n\nWhat is the derivative of `2x^3 + x^2 + 2x + 1`? Give me the solution step-by-step\n\n\n\n# Get the next step\nprint(lazy_lm.get_next_step())\n\nTo find the derivative of the given function, we'll use the power rule and the constant rule of differentiation. Let's start with the first term:\n\nStep 1: Find the derivative of 2x^3\n\nThe power rule states that for a term ax^n, the derivative is nax^(n-1).\nFor 2x^3, we have:\na = 2, n = 3\nSo, the derivative of 2x^\n\n\n\n# Query the current step\nprint(lazy_lm.ask_question(\"I don't understand this step\"))\n\nI apologize for any confusion. I'd be happy to explain this step in more detail without advancing to the next step.\n\nIn this step, we're focusing on finding the derivative of the first term in the given expression, which is 2x^3.\n\nTo do this, we're using the power rule of differentiation. The power rule states that for a term in the form ax^n (where 'a' is a constant and 'n' is the power\n\n\n\n# Get the next step\nprint(lazy_lm.get_next_step())\n\nStep 2: Complete the derivative of 2x^3\n\nContinuing from the previous step, we apply the power rule to 2x^3:\n\nThe derivative of 2x^3 is:\n3 · 2x^(3-1) = 3 · 2x^2 = 6x^2",
    "crumbs": [
      "LazyLM"
    ]
  },
  {
    "objectID": "index.html#understanding-lazy-evaluation",
    "href": "index.html#understanding-lazy-evaluation",
    "title": "LazyLM",
    "section": "Understanding Lazy Evaluation",
    "text": "Understanding Lazy Evaluation\n\nA Note on Lazy Evaluation in Programming\nThe concept of lazy evaluation is well-established in functional programming languages, where the evaluation of an expression is only done when the value of the expression is needed. This is also known as call-by-need. The contrast to this evaluation strategy is what’s called “eager” or strict evaluation.\nThe concept of lazy evaluation is well-established in functional programming languages, where the evaluation of an expression is only done when the value (or terminial) of the expression is needed. This is also known as call-by-need. The contrast of this evaluation strategy is what’s called “eager” evaluation or strict evaluation. Eager evaluation evaluates all of the subexpressions of an expression regardless whether the value is used or not. For example the expression:\nfunc :: int -&gt; int -&gt; int\nfunc a b = a\nwill always just pass back the first argument to the function\n&gt;&gt; func (2+2) 100\n4\nWe get 4 because we are passing back that expression as part of the function, therefore we need to evaluate it to print it to the screen.\nHowever, what about this\n&gt;&gt;&gt; func (2 + 2) (100^1000000)\nIn an eager (or strict) language like python, the evaluation of that function would look something like this\nfunc((2+2), (100^1000000))\n\nfunc( 4, (100^1000000) )\n\nfunc( 4, 10000000000000000000000000000.....)\n\n4\nThat is a lot of wasted computation just for a function that returns the first argument!\nProgramming languages that support lazy evaluation have an evaluation strategy that looks more like this:\nfunc((2+2), (100^1000000))\n\n(2 + 2)\n\n4\nOur language “knows” that we don’t need the second argument, so why bother evaluating it?\n\n\nLazy Evaluation in the Context of Language Models\nLanguage models are inherently eager: given a prompt, they will continue to generate tokens until reaching an end-of-sequence token. However, this behavior is not always desirable, especially in educational contexts. For example, given a prompt such as:\n“What is the derivative of 2x^3 + x^2 + 2x + 1? Give me the solution step-by-step”\nA language model will generate the entire sequence of steps in one go. Something like this:\nGiven function: f(x) = 2x^3 + x^2 + 2x + 1\n\nStep 1: Differentiate each term separately using the power rule and constant rule.\nThe power rule states that the derivative of x^n is nx^(n-1).\nThe constant rule states that the derivative of a constant is 0.\n\na) Differentiate 2x^3:\n    d/dx(2x^3) = 2 * 3x^(3-1) = 6x^2\nb) Differentiate x^2:\n    d/dx(x^2) = 2x^(2-1) = 2x\nc) Differentiate 2x:\n    d/dx(2x) = 2\nd) Differentiate 1:\n    d/dx(1) = 0\n\nStep 2: Combine the results from each term.\nf'(x) = 6x^2 + 2x + 2 + 0\n\nStep 3: Simplify the expression.\nf'(x) = 6x^2 + 2x + 2\n\nTherefore, the derivative of 2x^3 + x^2 + 2x + 1 is 6x^2 + 2x + 2.\nIn the context of creating an application that can assist students with learning this content, a full trace will likely be suboptimal in facilitating a productive learning enviornment.\nMore abstractly, we can frame the problems as a problem initalization, a sequence of steps, and the final solution.\nsp_1 -&gt; sp_2 -&gt; sp_3 -&gt; ... -&gt; sp_n, where sp_i is the sub problem at step i for problem p\nWith some light definition in place we can frame the desired evaluation strategy like this:\npast(sp_1) -&gt; curr(sp_2) -&gt; future(sp_3 -&gt; ... -&gt; sp_n)\nwhere past are the steps that have already been evaluated, curr is the current step that has been evaluated, and future are all of the future steps to be evaluated.\nTo a language model, this is all just token sequences.\nTokenSequence_1 -&gt; TokenSequence_2 -&gt; TokenSequence_3 -&gt; ... -&gt; TokenSequence_n`\n|     sp_1    |    |     sp_2    |    |     sp_3    |    ...    |     sp_n    |\n\nLeveraging a model’s KV cache for memoizing the compute done on TokenSequences that have already been computed we can frame our evaluation strategy to look much more “lazy”.\nmemoized(TokenSequence_1 -&gt; TokenSequence_2) -&gt; TokenSequence_3 -&gt; future(TokenSequence_4 -&gt; ... -&gt; TokenSequence_n)\nwhere we can get roughly the desired evaluation strategy having the LLM compute the next sequence it samples as a sub problem and nothing more.",
    "crumbs": [
      "LazyLM"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "LazyLM Core",
    "section": "",
    "text": "This is the state called LazyState that will be passed to the language model. This should essentially be able to do the following:\nsource",
    "crumbs": [
      "LazyLM Core"
    ]
  },
  {
    "objectID": "core.html#the-lazy-evaluation-flow",
    "href": "core.html#the-lazy-evaluation-flow",
    "title": "LazyLM Core",
    "section": "The Lazy Evaluation Flow",
    "text": "The Lazy Evaluation Flow\nThis simple framework effectivly shows how we can wrape a language model capable of step-by-step reasoning to create a lazy evaluator.\nThis approach follows these system design steps:\n\nProblem Initialization: A state manager is initalized with a problem\nPrompting Strategy: Prompt the language model to generate the next step given the context in the state manager.\nState Update: State Manager records the newly generated step and updates.\nUser Interaction: User interaction is held within a different state manager question_history which does not affect the overall state of the current problem.\nAdaptive Response: Based on the current input, the Lazy Evaluator decides to either 1) Generate the next step or 2) Provide a response to the user’s question given the current state of the problem and the question history.\n\nFinally, let’s patch different model provider’s APIs\n\nsource\n\nAnthropicVertex.lazy\n\n AnthropicVertex.lazy (problem:str)\n\nEntry point of the LazyLM Framework for the AnthropicVertex client API",
    "crumbs": [
      "LazyLM Core"
    ]
  }
]